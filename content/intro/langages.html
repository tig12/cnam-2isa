<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="utf-8">
    <title>Langages de programmation | NFP121 Millau</title>
    <meta name="description" content="Le problème de la décision et la manière dont il a été résolu, par Alan Turing et Alonzo Church.">
    <meta name="robots" content="index,follow">
    <link href="../../static/style.css" rel="stylesheet" type="text/css">
    <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
    <meta name="dcterms.rights" content="Creative commons by-sa 4.0">
    <meta name="dcterms.rightsHolder" content="Thierry Graff">
    <meta name="dcterms.dateCopyrighted" content="2017">
    <script async defer data-domain="larzac.info" src="http://plausible.tig12.net:8000/js/plausible.js"></script>
</head>

<body>

<nav class="prevnext">
    <a class="top" title="NFP121" href="../../index.html">&uarr;</a>
    <a class="next" title="Next" href="turing.html">&rarr;</a>
    <a class="prev" title="Previous" href="INSTALL.html">&larr;</a>
</nav>

<header>
<h1>Langages de programmation</h1>
</header>

<article>

<!-- ********************************************************************************* -->
<h2>Le problème de la décision (Entscheidungproblem)</h2>
Les deux grandes familles de langages informatiques (<b>langages impératifs</b> et <b>langages fonctionnels</b>) sont nés en cherchant à répondre à une question formulée plusieurs fois par David Hilbert (mathéméticien allemand) à partir de 1900 et publiée en 1928 :

<br>
<div class="border margin05 padding05 inline-block">
    Existe-t-il un processus permettant de déterminer en un nombre fini d'opérations
    <br>si une assertion de la logique du premier ordre est vraie ?
</div>

<br>Autrement dit : si on a une assertion logique, existe-t-il toujours un moyen de savoir si elle est vraie, ou existe-t-il des assertions indécidables ?
<br>
<br>Peut-on savoir si un système logique est <b>décidable</b> ou pas ?
<br>
<br><b>La réponse est "non"</b> : il peut exister des assertions qu'on ne peut pas démontrer.
<br>
<br>Cette réponse a été trouvée de deux manières différentes presque simultanément en 1936.

<ul class="spaced naked">
    <li>
        <b>Alan Turing</b> a répondu en inventant pour l'occasion la <b>machine de Turing</b>.
        <br>Cette approche a fourni une base théorique aux langages impératifs.
    </li>
    <li>
        <b>Alonzo Church</b> a répondu en inventant le <b>lambda-calcul</b> (lambda = lettre grecque &lambda;).
        <br>Cette approche a fourni une base théorique aux langages fonctionnels.
    </li>
</ul>

Church et Turing ont ensuite travaillé ensemble.
<br>L'équivalence entre les machines de Turing et le lambda-calcul a été démontré par Turing en 1937 :
<br>Une fonction est calculable par une machine de Turing si et seulement si elle est calculable en utilisant le lambda-calcul.
<br>Autrement dit, tout problème pouvant être résolu en programmation impérative peut l'être en programmation fonctionnelle, et vice-versa.
<br>
<br>La décidabilité est une des caractéristiques qu'un système de déduction devrait satisfaire ; les autres caractéristiques sont :
<ul class="margin0 simple">
    <li>la complétude</li>
    <li>la correction</li>
    <li>la cohérence</li>
</ul>
Voir <a href="https://fr.wikipedia.org/wiki/Logique_math%C3%A9matique#Syst%C3%A8mes_de_d%C3%A9duction">wikipedia</a>.



<!-- ************************************* -->
<!-- 
<h3><a name="1-1-logique-du-premier-ordre">Logique du premier ordre</a></h3>

Revenons à la question de départ :
<br><div class="border margin05 padding05 inline-block">
    Existe-t-il un processus permettant de déterminer en un nombre fini d'opérations
    <br>si une assertion de la logique du premier ordre est vraie ?
</div><br>

Pour répondre à cette question, il faut définir précisément ses termes :
<br>- Qu'est-ce que la logique du premier ordre ?
<br>- Qu'est-ce qu'une opération ?
<br>- Qu'est-ce qu'un processus ?
<h3>Logique du premier ordre</h3>
<h3><a name="1-2-operation">Opération</a></h3>
<h3><a name="1-3-processus">Processus</a></h3>
-->

<!-- ********************************************************************************* -->
<h2><a name="2-la-machine-de-turing">La machine de Turing</a></h2>

Une machine de Turing est un automate avec une tête de lecture et une bande de papier faite de cases ; qui ne peut exécuter qu'un nombre très limité d'opérations (lire une case, écrire, effacer, aller à la case de droite, aller à la case de gauche) ; qui peut mémoriser son <b>état</b> ; qui peut prendre une décision en fonction de la valeur de la case courante et de l'état courant de la machine.

<div class="margin"><img class="border" src="img/turing.svg" alt="Machine de Turing"></div>

La machine de Turing a servi de modèle pour le "paradigme impératif". Un programme est une suite d'<b>instructions</b> qui indiquent quoi faire à la machine, en s'appuyant sur la notion d'état d'une machine (état de sa mémoire).

<br><br>La machine de Turing sera abordée plus en détail (<a href="turing.html">voir cette page</a>).

<!-- ********************************************************************************* -->
<h2><a name="3-le-lambda-calcul">Le lambda-calcul</a></h2>

Le lambda-calcul est un système dans lequel tout est fonction et doté d'une seule opération : l'application d'une fonction à une autre. Tout est <i>lambda-expression</i> ; toute expression est remplacée par une fonction.
<br>Par exemple <code>3x + 1</code> est remplacé par la fonction qui à <code>x</code> associe <code>3x + 1</code> ; on note : <code>&lambda;x.3*x+1</code>
<br>Le lambda calcul n'utilise que deux notations :
<ul>
    <li>
        <i>Abstraction</i>
        <br><code><b>&lambda;x.M</b></code> désigne une fonction anonyme dont le paramètre est noté <code>x</code> et dont le corps est noté <code>M</code>.
        <br>Si M est une &lambda;-expression, λx.M est aussi une λ-expression et représente la fonction qui à x associe M.
        <br>(noter le point qui sépare le nom du paramètre et le corps de la fonction)
    </li>
    <li>
        <i>Application</i>
        <br><code><b>MN</b></code> : désigne l'application de la fonction <code>M</code> avec comme paramètre <code>N</code> ; on est habitués à noter plutôt <code>M(N)</code>.
    </li>
</ul>

La seule règle pour passer d'une expression à une autre est la <i>réduction &beta;</i> : <code><b>(&lambda;x.M)N &rarr; <sub>&beta;</sub> M[x:=N]</b></code>
<br>Appliquer la &lambda; expression <code>&lambda;x.M</code> au paramètre <code>N</code> revient au même que de remplacer <code>x</code> par <code>N</code> dans le corps de la fonction <code>M</code>.

Le lambda calcul a servi de modèle pour le "paradigme fonctionnel". "Tout est fonction" ; les notions fondamentales sont celles de fonction, de valeur, d'application d'une fonction à une valeur.

<!-- 
Voir <a href="https://mathdevelopment.tumblr.com/post/182509661410/lambda-calculus-for-programmers">cette page</a>
-->

<!-- ********************************************************************************* -->
<h2>Parenthèse mathématique</h2>
Voir les pages "<a href="maths/ensembles.html">Ensembles</a>", "<a href="maths/categories.html">Catégories</a>", "<a href="maths/fonctions/.html">Fonctions</a>".


<!-- ********************************************************************************* -->
<h2>Fonctions</h2>

Dans un langage fonctionnel "pur", le terme fonction est à prendre au sens mathématique du terme.
<br><code>f(x) = y</code>.
<br>En informatique, cela se traduit par une fonction qui prend <code>x</code> en paramètre et renvoie <code>y</code> :
<pre>
// isVoyelle('a') = true
// isVoyelle('r') = false
boolean isVoyelle(char c){ ... }
</pre>
Une fonction transforme un <b>type de donnée</b> en un autre :

<code class="block margin">char -- isVoyelle() --> boolean</code>


<!-- ************************************* -->
<h3>Fonction pure</h3>
Une fonction est dite <b>pure</b> si elle n'a pas d'effet de bord ; pour une valeur donnée d'un argument, la valeur du retour sera toujours la même.

<br><br>En pratique, quand on programme, les fonctions ne sont pas pures, elles peuvent :
<ul class="margin0 simple">
    <li>Renvoyer des erreurs ou exceptions.</li>
    <li>Dépendre de l'extérieur de la fonction (par ex. variables globales, date et heure de l'exécution, disponibilité d'une ressource extérieure).</li>
    <li>Modifier le système (écrire dans un fichier, une base de données).</li>
</ul>

Par exemple, la fonction <code>test()</code> suivante n'est pas pure.

<pre>
class ExempleFonctionImpure {
    
    private static int i = 0;
    
    public static String test(int j){
        i += j;
        return i;
    }
    
}
</pre>
En effet, <code>test(1)</code> va renvoyer 1 au premier appel, puis 2 au second appel etc.

<br>La <b>transparence référentielle</b> est une propriété d'une expression : on peut la remplacer par sa valeur sans changer le comportement du programme. Cette propriété n'est pas vérifiée par la fonction <code>test()</code>.

<br><br>Mais les caractéristiques "impures" des fonctions peuvent être construites à partir de la définition mathématique d'une fonction.

<!-- ************************************* -->
<h3>Mémoïsation</h3>
Si une fonction est pure, pour un argument donné elle renvoie toujours la même valeur.
<br>On peut donc fabriquer un cache : enregistrer dans un tableau toutes les valeurs possibles que peut prendre le argument, avec la valeur de retour de la fonction. on dit qu'on peut la <strong>mémoïser</strong>.
<br>Que l'on renvoie la valeur calculée ou la valeur stockée dans le cache, on aura le même résultat.
<br>On dit que la fonction est <strong>mémoïsable</strong>.
<br>
<br>En pratique, on ne peut pas le faire pour des types infinis (dont le cardinal de l'ensemble des valeurs du type est infini).

<!-- ************************************* -->
<h3>Curryfication</h3>
La notion de fonction pure est plus large que la notion mathématique de fonction ; en effet, une fonction pure peut avoir plusieurs arguments en entrée (et dans certains langages renvoyer plusieurs valeurs).
<br>Mais on peut transformer une fonction prenant plusieurs arguments en une fonction prenant le premier argument et renvoyant une fonction prenant les arguments suivants. Ce procédé s'appelle la <b>curryfication</b> (le nom vient de Haskel Curry).

<br><br>Exemple en PHP :
<pre>
&lt;?php
function uncurried_add($x, $y){
    return $x + $y;
}

// Avant PHP 7.4
function curried_add($x){
    return function($y) use($x) { return $x + $y; };
}

// Depuis PHP 7.4 ("arrow functions")
function curried_add2($x){
    return fn($y) => $x + $y;
}

echo "uncurried_add(3, 5) = " . uncurried_add(3, 5) . "\n";
echo "curried_add(3)(5) = " . curried_add(3)(5) . "\n";
echo "curried_add2(3)(5) = " . curried_add2(3)(5) . "\n";
</pre>
(<a href="../../exemples/intro/curryfication/curry.php">code source</a>)

<br><br>Voir aussi un <a href="../../exemples/intro/curryfication/TestCurry.java">exemple en java</a>.

<br>
<br>Vocabulaire :
<br>Une <b>fonction d'ordre supérieur</b> est une fonction qui prend en paramètre une fonction ou qui renvoie une fonction.

<!-- ************************************* -->
<h3><a name="4-2-functions-as-first-class-citizens">Functions as first class citizens</a></h3>
Les fonctions font partie des types connus des langages fonctionnels ; elles peuvent être
<br>- nommées
<br>- évaluées
<br>- passées comme argument
<br>- renvoyées comme résultat
<br>- utilisées partout où une expression peut l'être.



<!-- ********************************************************************************* -->
<h2><a name="4-langages-imperatifs-et-fonctionnels">Langages impératifs et fonctionnels</a></h2>
<!-- 
Why the name? Many years ago, before there were any computers, the logician
Alonzo Church wanted to formalize what it means for a mathematical function to be
effectively computable. (Curiously, there are functions that are known to exist, but
nobody knows how to compute their values.) He used the Greek letter lambda (λ) to
mark parameters, somewhat like
λfirst. λsecond. first.length() - second.length()
Why the letter λ? Did Church run out of letters of the alphabet? Actually, the
venerable Principia Mathematica (see
http://plato.stanford.edu/entries/principia-mathematica) used the ^ accent to
denote function parameters, which inspired Church to use an uppercase
lambda Λ. But in the end, he switched to the lowercase version. Ever since,
an expression with parameter variables has been called a lambda expression.
-->

On se retrouve donc avec deux manières de programmer équivalentes mais différentes.

<!-- ************************************* -->
<h3><a name="4-1-exemple-factorielle">Exemple : factorielle</a></h3>

En java :
<pre>
public class Factorial{
    public static int compute(int n){
        int res = 1;
        for (int c = 1; c <= n; c++)
            res = res * c;
        return res;
    }
}
</pre>

En ~ lambda-calcul :
<pre>&lambda; n.if n=0 then 1 else n*(fact (n-1))</pre>

En Ocaml :
<pre>
let rec fact =
    function n -> if n=0 then 1 else n*(fact (n-1))
</pre>

En Haskell :
<br>

<div class="flex-wrap">

<pre>
factorial n = if n < 2
              then 1
              else n * factorial (n - 1)
</pre>

<div>ou</div>

<pre>
factorial 0 = 1
factorial n = n * factorial (n - 1)
</pre>

</div>


En Lisp :
<pre>
(defun factorial (n)
  (if (= n 1)              
      1                           
      (* n (factorial (- n 1))))) 
</pre>

Dans un langage purement fonctionnel, une fonction ne fait qu'une seule chose : elle prend un (ou plusieurs) argument(s) en entrée et renvoie une valeur en sortie.
<br>Le corps de la fonction est comme un gros return, on se concentre sur ce qu'on renvoie, pas ce qu'on fait entre temps.
<br>La syntaxe facilite cette orientation.
<br>Par exemple en java, <code>if then else</code> est une <i>instruction composée</i>, qui <i>fait</i> des choses. En Ocaml, c'est une <i>expression</i>, qui <i>calcule</i> la valeur d'un type.

<!-- ************************************* -->
<h3><a name="4-3-un-concensus">Un concensus</a></h3>
L'introduction des lambda expressions en java correspond à un mouvement de fond dans de nombreux langages impératifs.
<br>Un consensus a peu à peu émergé : les langages fonctionnels sont plus faciles à tester, débugger et paralléliser que les langages impératifs.
<br>
<br>Depuis java 8, java est décrit par Oracle comme "légèrement fonctionnel" : fournit par convenance les idiomes fonctionnels les plus souvent utilisés. Mais java ne possède pas de type "fonction".

</article>

</body>
</html>
